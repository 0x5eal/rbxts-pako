/* pako 0.0.0 nodeca/pako */!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.pako=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
'use strict';


var zlib_inflate = _dereq_('./zlib/inflate.js');
var utils = _dereq_('./zlib/utils');
var c = _dereq_('./zlib/constants');
var msg = _dereq_('./zlib/messages');
var zstream = _dereq_('./zlib/zstream');

// return sliced buffer, trying to avoid new objects creation and mem copy
function sliceBuf(buf, size) {
  if (buf.length === size) { return buf; }

  return utils.typedOk() ? buf.subarray(0, size) : buf.slice(0, size);
}

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (boolean) - do raw inflate
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
var Inflate = function(options) {

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 15 + 32 // By default - autodetect deflate/gzip
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }
};

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That flush internal pending buffers and call
 * [[Inflate#onEnd]].
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function(data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  strm.next_in = data;
  strm.next_in_index = 0;
  strm.avail_in = strm.next_in.length;
  strm.next_out = utils.arrayCreate(chunkSize);

  do {
    strm.avail_out = this.options.chunkSize;
    strm.next_out_index = 0;
    status = zlib_inflate.inflate(strm, _mode);    /* no bad return value */

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if(strm.next_out_index) {
      this.onData(sliceBuf(strm.next_out, strm.next_out_index));
      // Allocate buffer for next chunk, if not last
      if (strm.avail_in > 0 || strm.avail_out === 0) {
        strm.next_out = utils.arrayCreate(this.options.chunkSize);
      }
    }
  } while (strm.avail_in > 0 || strm.avail_out === 0);

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array): ouput data. Type of array depends
 *   on js engine support.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell inflate that input stream complete
 * or error happenned. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function(status) {
  // On success - join
  if (status === c.Z_OK) {
    this.result = utils.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = msg[status];
};


/**
 * inflate(data[, options]) -> Uint8Array|Array
 * - data (Uint8Array|Array): input data to compress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate alrorythm and `options`.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , in = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , out;
 *
 * out = pako.inflate(data);
 * if (out.err) { throw new Error(out.err); }
 * console.log(pako.inflate(out.result));
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array
 * - data (Uint8Array|Array): input data to compress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;

},{"./zlib/constants":2,"./zlib/inflate.js":3,"./zlib/messages":4,"./zlib/utils":5,"./zlib/zstream":6}],2:[function(_dereq_,module,exports){
module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:         (-1),
  Z_STREAM_ERROR:  (-2),
  Z_DATA_ERROR:    (-3),
  Z_MEM_ERROR:     (-4),
  Z_BUF_ERROR:     (-5),
  Z_VERSION_ERROR: (-6),

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                  1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8,
  //Z_NULL:                 null // Use -1 or null, depending on var type
};
},{}],3:[function(_dereq_,module,exports){
'use strict';

//var utils = require('utils');

var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

//function Code() {
//  this.op = 0;           /* operation, extra bits, table bits */
//  this.bits = 0;         /* bits in this part of the code */
//  this.val = 0;          /* offset in table or code value */
//}

function InflateState() {
  this.mode = -1;             /* current inflate mode */
  this.last = 0;              /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = 0;          /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  this.head = 0;              /* where to save gzip header information */
  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = -1;           /* allocated sliding window, if needed */
  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */
  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */
  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */
  /* fixed and dynamic code tables */
  this.lencode = -1;          /* starting table for length/literal codes */
  this.distcode = -1;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */
  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = 0;             /* next available space in codes[] */

  //unsigned short array
  //todo: test later with Uint16Array
  this.lens = new Array(320); /* temporary storage for code lengths */
  this.work = new Array(280); /* work area for code table building */

  this.codes = new Array(ENOUGH);           /* space for code tables */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(/*strm*/) {

}

function inflateReset(/*strm*/) {

}

function inflateReset2(/*strm, windowBits*/) {

}

function inflateInit2(strm/*, windowBits, version, stream_size*/) {
  strm.state = new InflateState();
}

function inflateInit(/*strm, version, stream_size*/) {

}

function inflatePrime(/*strm, bits, value*/) {

}

/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
//function fixedtables(state) {
//
//}

/*
 Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
 defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
 those tables to stdout, which would be piped to inffixed.h.  A small program
 can simply call makefixed to do this:

 void makefixed(void);

 int main(void)
 {
 makefixed();
 return 0;
 }

 Then that can be linked with zlib built with MAKEFIXED defined and run:

 a.out > inffixed.h
 */
//function makefixed() {
//
//}

/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
//function updatewindow(strm, end, copy) {
//
//}

function inflate(/*strm, flush*/) {

}

function inflateEnd(/*strm*/) {

}

function inflateGetDictionary(/*strm, dictionary, dictLength*/) {

}

function inflateSetDictionary(/*strm, dictionary, dictLength*/) {

}

function inflateGetHeader(/*strm, head*/) {

}

/*
 Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
 or when out of input.  When called, *have is the number of pattern bytes
 found in order so far, in 0..3.  On return *have is updated to the new
 state.  If on return *have equals four, then the pattern was found and the
 return value is how many bytes were read including the last byte of the
 pattern.  If *have is less than four, then the pattern has not been found
 yet and the return value is len.  In the latter case, syncsearch() can be
 called again with more data and the *have state.  *have is initialized to
 zero for the first call.
 */
//function syncsearch(/*have, buf, len*/) {
//
//}

function inflateSync(/*strm*/) {

}

function inflateSyncPoint(/*strm*/) {

}

function inflateCopy(/*dest, source*/) {

}

function inflateUndermine(/*strm, subvert*/) {

}

function inflateMark(/*strm*/) {

}

exports.inflateResetKeep = inflateResetKeep;

exports.inflateReset = inflateReset;

exports.inflateReset2 = inflateReset2;

exports.inflateInit2 = inflateInit2;

exports.inflateInit = inflateInit;

exports.inflatePrime = inflatePrime;

exports.inflate = inflate;

exports.inflateEnd = inflateEnd;

exports.inflateGetDictionary = inflateGetDictionary;

exports.inflateGetHeader = inflateGetHeader;

exports.inflateSetDictionary = inflateSetDictionary;

exports.inflateSync = inflateSync;

exports.inflateSyncPoint = inflateSyncPoint;

exports.inflateCopy = inflateCopy;

exports.inflateUndermine = inflateUndermine;

exports.inflateMark = inflateMark;
},{}],4:[function(_dereq_,module,exports){
'use strict';

module.exports = {
  '2':    'need dictionary',     /* Z_NEED_DICT       2  */
  '1':    'stream end',          /* Z_STREAM_END      1  */
  '0':    '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};
},{}],5:[function(_dereq_,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Uint32Array !== 'undefined');

var _toString = Function.prototype.call.bind(Object.prototype.toString);
var isArray = Array.isArray || function (obj) { return _toString(obj) === '[object Array]'; };

// For debug/testing. Set true to force use untyped arrays
exports.forceUntyped = false;

function typedOk() {
  return TYPED_OK && !exports.forceUntyped;
}

exports.typedOk = typedOk;


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof(source) !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


exports.arraySet = function (dest, src, src_offs, len, dest_offs) {

  // Suppose, that with typed array support destination is
  // always typed - don't check it
  if (typedOk() && (!isArray(src))) {

    // optimize full copy
    //if ((src_offs === 0) && (src.length === len)) {
    //  dest.set(src, dest_offs);
    //  return;
    //}

    dest.set(src.subarray(src_offs, src_offs+len), dest_offs);
    return;
  }

  // Fallback to ordinary array
  for(var i=0; i<len; i++) {
    dest[dest_offs + i] = src[src_offs + i];
  }
};


exports.arrayCreate = function (length) {

  if (typedOk()) {
    return new Uint8Array(length);
  }

  // Fallback to ordinary array
  return new Array(length);
};


exports.array16Create = function (length) {

  if (typedOk()) {
    return new Uint16Array(length);
  }

  // Fallback to ordinary array
  return new Array(length);
};


// Join array of chunks to single array.
// Expect Array of (Array(Bytes) || Uint8Array).
//
exports.flattenChunks = function(chunks) {
  var i, l, len, pos, chunk, result;

  if (typedOk()) {
    // calculate data length
    len = 0;
    for (i=0, l=chunks.length; i<l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i=0, l=chunks.length; i<l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }

  // Fallback for untyped arrays
  return [].concat.apply([], chunks);
};

},{}],6:[function(_dereq_,module,exports){
'use strict';


function ZStream() {
  /* next input byte */
  this.next_in = null;
  /* number of bytes available at next_in */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.next_out = null;
  /* remaining free space at next_out */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  //this.msg = c.Z_NULL;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;
},{}]},{},[1])
(1)
});